<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Webapck5核心打包原理全流程解析 | uncle ge</title>
    <meta name="generator" content="VuePress 1.9.5">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.ece217d8.css" as="style"><link rel="preload" href="/assets/js/app.6fe35129.js" as="script"><link rel="preload" href="/assets/js/3.c61b2de1.js" as="script"><link rel="preload" href="/assets/js/1.92ef6ebe.js" as="script"><link rel="preload" href="/assets/js/20.adcd6122.js" as="script"><link rel="prefetch" href="/assets/js/10.c14b5b6d.js"><link rel="prefetch" href="/assets/js/11.8e46e5d2.js"><link rel="prefetch" href="/assets/js/12.322a63a6.js"><link rel="prefetch" href="/assets/js/13.49ac157a.js"><link rel="prefetch" href="/assets/js/14.8e8ab288.js"><link rel="prefetch" href="/assets/js/15.988bcefa.js"><link rel="prefetch" href="/assets/js/16.c2abb771.js"><link rel="prefetch" href="/assets/js/17.4bc27c1d.js"><link rel="prefetch" href="/assets/js/18.ae0d444f.js"><link rel="prefetch" href="/assets/js/19.7b5e0a98.js"><link rel="prefetch" href="/assets/js/4.92a6ef30.js"><link rel="prefetch" href="/assets/js/5.ba687ca0.js"><link rel="prefetch" href="/assets/js/6.5cc60031.js"><link rel="prefetch" href="/assets/js/7.8604224d.js"><link rel="prefetch" href="/assets/js/8.0a19e8eb.js"><link rel="prefetch" href="/assets/js/9.70c7ed9b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.ece217d8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-1aefc0b4><div data-v-1aefc0b4><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-1aefc0b4 data-v-1aefc0b4><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-25ba6db2 data-v-1aefc0b4 data-v-1aefc0b4><h3 class="title" data-v-25ba6db2 data-v-25ba6db2>uncle ge</h3> <p class="description" data-v-25ba6db2 data-v-25ba6db2></p> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><span data-v-25ba6db2>jingge</span>
            
          <!---->
          2022
        </a></span></div></div> <div class="hide" data-v-1aefc0b4><header class="navbar" data-v-1aefc0b4><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/assets/img/avatar.jpg" alt="uncle ge" class="logo"> <span class="site-name">uncle ge</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/Vue/" class="nav-link"><i class="undefined"></i>
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/categories/JavaScript/" class="nav-link"><i class="undefined"></i>
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/categories/前端/" class="nav-link"><i class="undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/categories/devops/" class="nav-link"><i class="undefined"></i>
  devops
</a></li><li class="dropdown-item"><!----> <a href="/categories/webpack/" class="nav-link"><i class="undefined"></i>
  webpack
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-1aefc0b4></div> <aside class="sidebar" data-v-1aefc0b4><div class="personal-info-wrapper" data-v-39576ba9 data-v-1aefc0b4><img src="/assets/img/avatar.jpg" alt="author-avatar" class="personal-img" data-v-39576ba9> <h3 class="name" data-v-39576ba9>
    jingge
  </h3> <div class="num" data-v-39576ba9><div data-v-39576ba9><h3 data-v-39576ba9>10</h3> <h6 data-v-39576ba9>Articles</h6></div> <div data-v-39576ba9><h3 data-v-39576ba9>6</h3> <h6 data-v-39576ba9>Tags</h6></div></div> <ul class="social-links" data-v-39576ba9><li class="social-item" data-v-39576ba9><i class="iconfont reco-github" style="color:#e15b64;" data-v-39576ba9></i></li><li class="social-item" data-v-39576ba9><i class="iconfont reco-npm" style="color:#fb9b5f;" data-v-39576ba9></i></li></ul> <hr data-v-39576ba9></div> <nav class="nav-links"><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/Vue/" class="nav-link"><i class="undefined"></i>
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/categories/JavaScript/" class="nav-link"><i class="undefined"></i>
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/categories/前端/" class="nav-link"><i class="undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/categories/devops/" class="nav-link"><i class="undefined"></i>
  devops
</a></li><li class="dropdown-item"><!----> <a href="/categories/webpack/" class="nav-link"><i class="undefined"></i>
  webpack
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-25ba6db2 data-v-1aefc0b4><h3 class="title" data-v-25ba6db2 data-v-25ba6db2>Webapck5核心打包原理全流程解析</h3> <!----> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><span data-v-25ba6db2>jingge</span>
            
          <!---->
          2022
        </a></span></div></div> <div data-v-1aefc0b4><main class="page" style="padding-right:0;"><section><div class="page-title"><h1 class="title">Webapck5核心打包原理全流程解析</h1> <div data-v-f875f3fc><i class="iconfont reco-account" data-v-f875f3fc><span data-v-f875f3fc>jingge</span></i> <i class="iconfont reco-date" data-v-f875f3fc><span data-v-f875f3fc>4/7/2022</span></i> <!----> <i class="tags iconfont reco-tag" data-v-f875f3fc><span class="tag-item" data-v-f875f3fc>w</span><span class="tag-item" data-v-f875f3fc>e</span><span class="tag-item" data-v-f875f3fc>b</span><span class="tag-item" data-v-f875f3fc>p</span><span class="tag-item" data-v-f875f3fc>a</span><span class="tag-item" data-v-f875f3fc>c</span><span class="tag-item" data-v-f875f3fc>k</span><span class="tag-item" data-v-f875f3fc>5</span></i></div></div> <div class="theme-reco-content content__default"><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eba36c6f269a4489b0229fbb2519d409~tplv-k3u1fbpfcp-zoom-crop-mark:1304:1304:1304:734.awebp?" alt="image"></p> <h2 id="写在前边"><a href="#写在前边" class="header-anchor">#</a> 写在前边</h2> <p>Webpack在前端前端构建工具中可以堪称中流砥柱般的存在，日常业务开发、前端基建工具、高级前端面试...任何场景都会出现它的身影。
也许对于它的内部实现机制你也许会感到疑惑，日常工作中基于Webpack Plugin/Loader之类查阅API仍然不明白各个参数的含义和应用方式。
其实这一切原因本质上都是基于Webpack工作流没有一个清晰的认知导致了所谓的“面对API无从下手”开发。
文章中我们会从如何实现模块分析项目打包的角度出发，使用最通俗，最简洁，最明了的代码带你揭开Webpack背后的神秘面纱，带你实现一个简易版Webpack，从此对于任何webpack相关底层开发了然于胸。
这里我们只讲「干货」，用最通俗易懂的代码带你走进webpack的工作流。</p> <h2 id="我希望你能掌握的前置知识"><a href="#我希望你能掌握的前置知识" class="header-anchor">#</a> 我希望你能掌握的前置知识</h2> <ul><li>Tapable</li></ul> <p>Tapable包本质上是为我们更方面创建自定义事件和触发自定义事件的库，类似于Nodejs中的EventEmitter Api。
Webpack中的插件机制就是基于Tapable实现与打包流程解耦，插件的所有形式都是基于Tapable实现。</p> <ul><li>Webpack Node Api</li></ul> <p>基于学习目的我们会着重于Webpack Node Api流程去讲解，实际上我们在前端日常使用的npm run build命令也是通过环境变量调用bin脚本去调用Node Api去执行编译打包。</p> <ul><li>Babel</li></ul> <p>Webpack内部的AST分析同样依赖于Babel进行处理，如果你对Babel不是很熟悉。我建议你可以先去阅读下这两篇文章「前端基建」带你在Babel的世界中畅游、# 从Tree Shaking来走进Babel插件开发者的世界。</p> <blockquote><p>当然后续我也会去详解这些内容在Webpack中的应用，但是我更加希望在阅读文章之前你可以去点一点上方的文档稍微了解一下前置知识。</p></blockquote> <h2 id="流程梳理"><a href="#流程梳理" class="header-anchor">#</a> 流程梳理</h2> <p>在开始之前我们先对于整个打包流程进行一次梳理。
这里仅仅是一个全流程的梳理，现在你没有必要非常详细的去思考每一个步骤发生了什么，我们会在接下来的步骤中去一步一步带你串联它们。</p> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1c757a6c9c6416e93dde9db73431e83~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?" alt="image"></p> <p>整体我们将会从上边5个方面来分析==Webpack==打包流程:</p> <ol><li><p><strong>初始化参数阶段</strong>。
这一步会从我们配置的webpack.config.js中读取到对应的配置参数和shell命令中传入的参数进行合并得到最终打包配置参数。</p></li> <li><p><strong>开始编译准备阶段</strong>
这一步我们会通过调用webpack()方法返回一个compiler方法，创建我们的compiler对象，并且注册各个Webpack Plugin。找到配置入口中的entry代码，调用compiler.run()方法进行编译。</p></li> <li><p><strong>模块编译阶段</strong>
从入口模块进行分析，调用匹配文件的loaders对文件进行处理。同时分析模块依赖的模块，递归进行模块编译工作。</p></li> <li><p><strong>完成编译阶段</strong>
在递归完成后，每个引用模块通过loaders处理完成同时得到模块之间的相互依赖关系。</p></li> <li><p><strong>输出文件阶段</strong>
整理模块依赖关系，同时将处理后的文件输出到ouput的磁盘目录中。</p></li></ol> <p>接下来让我们详细的去探索每一步究竟发生了什么。</p> <h2 id="创建目录"><a href="#创建目录" class="header-anchor">#</a> 创建目录</h2> <p>工欲善其事，必先利其器。首先让我们创建一个良好的目录来管理我们需要实现的Packing tool吧！
让我们来创建这样一个目录:
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/936fa765f22542be8c49159fc9feaf38~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?" alt="image"></p> <ul><li><p>webpack/core存放我们自己将要实现的webpack核心代码。</p></li> <li><p>webpack/example存放我们将用来打包的实例项目。</p> <ul><li>webpack/example/webpak.config.js配置文件.</li> <li>webpack/example/src/entry1第一个入口文件</li> <li>webpack/example/src/entry1第二个入口文件</li> <li>webpack/example/src/index.js模块文件</li></ul></li> <li><p>webpack/loaders存放我们的自定义loader。</p></li> <li><p>webpack/plugins存放我们的自定义plugin。</p></li></ul> <h2 id="初始化参数阶段"><a href="#初始化参数阶段" class="header-anchor">#</a> 初始化参数阶段</h2> <p>往往，我们在日常使用阶段有两种方式去给webpack传递打包参数，让我们先来看看如何传递参数:</p> <h3 id="cli命令行传递参数"><a href="#cli命令行传递参数" class="header-anchor">#</a> Cli命令行传递参数</h3> <p>通常，我们在使用调用webpack命令时，有时会传入一定命令行参数，比如:</p> <div class="language-js extra-class"><pre class="language-js"><code>webpack <span class="token operator">--</span>mode<span class="token operator">=</span>production
# 调用webpack命令执行打包 同时传入mode为production
</code></pre></div><h3 id="webpack-config-js传递参数"><a href="#webpack-config-js传递参数" class="header-anchor">#</a> webpack.config.js传递参数</h3> <p>另一种方式，我相信就更加老生常谈了。</p> <p>我们在项目根目录下使用webpack.config.js导出一个对象进行webpack配置:</p> <div class="language- extra-class"><pre class="language-text"><code>const path = require('path')

// 引入loader和plugin ...
module.exports = {
  mode: 'development',
  entry: {
    main: path.resolve(__dirname, './src/entry1.js'),
    second: path.resolve(__dirname, './src/entry2.js'),
  },
  devtool: false,
  // 基础目录，绝对路径，用于从配置中解析入口点(entry point)和 加载器(loader)。
  // 换而言之entry和loader的所有相对路径都是相对于这个路径而言的
  context: process.cwd(),
  output: {
    path: path.resolve(__dirname, './build'),
    filename: '[name].js',
  },
  plugins: [new PluginA(), new PluginB()],
  resolve: {
    extensions: ['.js', '.ts'],
  },
  module: {
    rules: [
      {
        test: /\.js/,
        use: [
          // 使用自己loader有三种方式 这里仅仅是一种
          path.resolve(__dirname, '../loaders/loader-1.js'),
          path.resolve(__dirname, '../loaders/loader-2.js'),
        ],
      },
    ],
  },
};
</code></pre></div><p>同时这份配置文件也是我们需要作为实例项目example下的实例配置，接下来让我们修改example/webpack.config.js中的内容为上述配置吧。</p> <blockquote><p>当然这里的loader和plugin目前你可以不用理解，接下来我们会逐步实现这些东西并且添加到我们的打包流程中去。</p></blockquote> <h2 id="实现合并参数阶段"><a href="#实现合并参数阶段" class="header-anchor">#</a> 实现合并参数阶段</h2> <p>这一步，让我们真正开始动手实现我们的webpack吧！</p> <p>首先让我们在webpack/core下新建一个index.js文件作为核心入口文件。</p> <p>同时建立一个webpack/core下新建一个webpack.js文件作为webpack()方法的实现文件。</p> <p>首先，我们清楚在NodeJs Api中是通过webpack()方法去得到compiler对象的。
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/136db48b37774dad92b87c2009495500~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?" alt="image"></p> <p>此时让我们按照原本的webpack接口格式来补充一下index.js中的逻辑:</p> <ul><li>我们需要一个webpack方法去执行调用命令。</li> <li>同时我们引入webpack.config.js配置文件传入webpack方法。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// index.js
const webpack = require('./webpack');
const config = require('../example/webpack.config');
// 步骤1: 初始化参数 根据配置文件和shell参数合成参数
const compiler = webpack(config);
</code></pre></div><p>嗯，看起来还不错。==接下来让我们去实现一下webpack==.js:</p> <div class="language- extra-class"><pre class="language-text"><code>function webpack(options) {
  // 合并参数 得到合并后的参数 mergeOptions
  const mergeOptions = _mergeOptions(options);
}

// 合并参数
function _mergeOptions(options) {
  const shellOptions = process.argv.slice(2).reduce((option, argv) =&gt; {
    // argv -&gt; --mode=production
    const [key, value] = argv.split('=');
    if (key &amp;&amp; value) {
      const parseKey = key.slice(2);
      option[parseKey] = value;
    }
    return option;
  }, {});
  return { ...options, ...shellOptions };
}

module.exports = webpack;
</code></pre></div><p>这里我们需要额外说明的是
==webpack==文件中需要导出一个名为==webpack==的方法，同时接受外部传入的配置对象。这个是我们在上述讲述过的。</p> <p>当然关于我们合并参数的逻辑，是将外部传入的对象和执行shell时的传入参数进行最终合并。</p> <p>在Node Js中我们可以通过process.argv.slice(2)来获得shell命令中传入的参数，比如:</p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e003c7741b54e5ebf1a5c90f9f96875~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?" alt="image"></p> <p>当然_mergeOptions方法就是一个简单的合并配置参数的方法，相信对于大家来说就是小菜一碟。
恭喜大家🎉，千里之行始于足下。这一步我们已经完成了打包流程中的第一步：合并配置参数。</p> <h2 id="编译阶段"><a href="#编译阶段" class="header-anchor">#</a> 编译阶段</h2> <p>在得到最终的配置参数之后，我们需要在webpack()函数中做以下几件事情:</p> <ul><li>通过参数创建compiler对象。我们看到官方案例中通过调用webpack(options)方法返回的是一个compiler对象。并且同时调用compiler.run()方法启动的代码进行打包。</li> <li>注册我们定义的webpack plugin插件。</li> <li>根据传入的配置对象寻找对应的打包入口文件。</li></ul> <h3 id="创建compiler对象"><a href="#创建compiler对象" class="header-anchor">#</a> 创建compiler对象</h3> <p>让我们先来完成index.js中的逻辑代码补全:</p> <div class="language- extra-class"><pre class="language-text"><code>// index.js
const webpack = require('./webpack');
const config = require('../example/webpack.config');
// 步骤1: 初始化参数 根据配置文件和shell参数合成参数
// 步骤2: 调用Webpack(options) 初始化compiler对象  
// webpack()方法会返回一个compiler对象

const compiler = webpack(config);

// 调用run方法进行打包
compiler.run((err, stats) =&gt; {
  if (err) {
    console.log(err, 'err');
  }
  // ...
});
</code></pre></div><p>可以看到，核心编译实现在于webpack()方法返回的compiler.run()方法上。
一步一步让我们来完善这个webpack()方法：</p> <div class="language- extra-class"><pre class="language-text"><code>// webpack.js
function webpack(options) {
  // 合并参数 得到合并后的参数 mergeOptions
  const mergeOptions = _mergeOptions(options);
  // 创建compiler对象
  const compiler = new Compiler(mergeOptions)
  
  return compiler
}

// ...
</code></pre></div><p>让我们在webpack/core目录下同样新建一个compiler.js文件，作为compiler的核心实现文件:</p> <div class="language- extra-class"><pre class="language-text"><code>// compiler.js
// Compiler类进行核心编译实现
class Compiler {
  constructor(options) {
    this.options = options;
  }

  // run方法启动编译 
  // 同时run方法接受外部传递的callback
  run(callback) {
  }
}

module.exports = Compiler
</code></pre></div><p>此时我们的Compiler类就先搭建一个基础的骨架代码。
目前，我们拥有了:</p> <ul><li>webpack/core/index.js作为打包命令的入口文件，这个文件引用了我们自己实现的webpack同时引用了外部的webpack.config.js(options)。调用webpack(options).run()开始编译。</li> <li>webpack/core/webpack.js这个文件目前处理了参数的合并以及传入合并后的参数new Compiler(mergeOptions)，同时返回创建的Compiler实力对象。</li> <li>webpack/core/compiler，此时我们的compiler仅仅是作为一个基础的骨架，存在一个run()启动方法。</li></ul> <h3 id="编写plugin"><a href="#编写plugin" class="header-anchor">#</a> 编写Plugin</h3> <p>还记得我们在webpack.config.js中使用了两个plugin---pluginA、pluginB插件吗。接下来让我们来依次实现它们:</p> <p>在实现Plugin前，我们需要先来完善一下compiler方法:</p> <div class="language- extra-class"><pre class="language-text"><code>const { SyncHook } = require('tapable');

class Compiler {
  constructor(options) {
    this.options = options;
    // 创建plugin hooks
    this.hooks = {
      // 开始编译时的钩子
      run: new SyncHook(),
      // 输出 asset 到 output 目录之前执行 (写入文件之前)
      emit: new SyncHook(),
      // 在 compilation 完成时执行 全部完成编译执行
      done: new SyncHook(),
    };
  }

  // run方法启动编译
  // 同时run方法接受外部传递的callback
  run(callback) {}
}

module.exports = Compiler;
</code></pre></div><p>这里，我们在Compiler这个类的构造函数中创建了一个属性hooks，它的值是三个属性run、emit、done。</p> <p>关于这三个属性的值就是我们上文提到前置知识的tapable的SyncHook方法，本质上你可以简单将SyncHook()方法理解称为一个Emitter Event类。
当我们通过new SyncHook()返回一个对象实例后，我们可以通过this.hook.run.tap('name',callback)方法为这个对象上添加事件监听，然后在通过this.hook.run.call()执行所有tap注册的事件。</p> <blockquote><p>当然webpack真实源码中，这里有非常多的hook。以及分别存在同步/异步钩子，我们这里更多的是为大家讲解清楚流程，所以仅列举了三个常见且简单的同步钩子。</p></blockquote> <p>此时，我们需要明白，我们可以通过Compiler类返回的实例对象上compiler.hooks.run.tap注册钩子。</p> <p>接下来让我们切回到webpack.js中，让我们来填充关于插件注册的逻辑:</p> <div class="language- extra-class"><pre class="language-text"><code>const Compiler = require('./compiler');

function webpack(options) {
  // 合并参数
  const mergeOptions = _mergeOptions(options);
  // 创建compiler对象
  const compiler = new Compiler(mergeOptions);
  // 加载插件
  _loadPlugin(options.plugins, compiler);
  return compiler;
}

// 合并参数
function _mergeOptions(options) {
  const shellOptions = process.argv.slice(2).reduce((option, argv) =&gt; {
    // argv -&gt; --mode=production
    const [key, value] = argv.split('=');
    if (key &amp;&amp; value) {
      const parseKey = key.slice(2);
      option[parseKey] = value;
    }
    return option;
  }, {});
  return { ...options, ...shellOptions };
}

// 加载插件函数
function _loadPlugin(plugins, compiler) {
  if (plugins &amp;&amp; Array.isArray(plugins)) {
    plugins.forEach((plugin) =&gt; {
      plugin.apply(compiler);
    });
  }
}

module.exports = webpack;
</code></pre></div><p>这里我们在创建完成compiler对象后，调用了_loadPlugin方法进行注册插件。</p> <p>有接触过webpack插件开发的同学，或多或少可能都有了解过。<strong>任何一个webpack插件都是一个类(当然类本质上都是funciton的语法糖)，每个插件都必须存在一个apply方法</strong>。</p> <p>这个==apply方==法会接受一个==compiler==对象。我们上边做的就是依次调用传入的plugin的apply方法并且传入我们的compiler对象。</p> <blockquote><p>这里我请你记住上边的流程，日常我们编写webpack plugin时本质上就是操作compiler对象从而影响打包结果进行。</p></blockquote> <blockquote><p>也许此时你并不是很理解这句话的含义，在我们串联完成整个流程之后我会为大家揭晓这个答案。</p></blockquote> <p>接下来让我们去编写这些个插件:
不了解插件开发的同学可以去稍微看一下官方的介绍，其实不是很难,我个人强烈建议如果不了解可以先去看看再回来结合上变讲的内容你一定会有所收获的。
首先让我们先创建文件:
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a53f0ccfda3d46e0adda75c20b69ea9d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?" alt="image"></p> <div class="language- extra-class"><pre class="language-text"><code>// plugin-a.js
// 插件A
class PluginA {
  apply(compiler) {
    // 注册同步钩子
    // 这里的compiler对象就是我们new Compiler()创建的实例哦
    compiler.hooks.run.tap('Plugin A', () =&gt; {
      // 调用
      console.log('PluginA');
    });
  }
}

module.exports = PluginA;
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>// plugin-b.js
class PluginB {
  apply(compiler) {
    compiler.hooks.done.tap('Plugin B', () =&gt; {
      console.log('PluginB');
    });
  }
}

module.exports = PluginB;
</code></pre></div><p>看到这里我相信大部分同学都已经反应过来了，compiler.hooks.done.tap不就是我们上边讲到的通过tapable创建一个SyncHook实例然后通过tap方法注册事件吗？</p> <p>没错！的确是这样，关于==webpack插件本质上就是通过发布订阅的模式，通过compiler上监听事件。然后再打包编译过程中触发监听的事件从而添加一定的逻辑影响打包结果==。</p> <p>我们在每个插件的apply方法上通过tap在编译准备阶段(也就是调用webpack()函数时)进行订阅对应的事件，当我们的编译执行到一定阶段时发布对应的事件告诉订阅者去执行监听的事件，从而达到在编译阶段的不同生命周期内去触发对应的plugin。</p> <blockquote><p>所以这里你应该清楚，我们在进行webpack插件开发时，compiler对象上存放着本次打包的所有相关属性，比如options打包的配置，以及我们会在之后讲到的各种属性。</p></blockquote> <h3 id="寻找entry入口"><a href="#寻找entry入口" class="header-anchor">#</a> 寻找entry入口</h3> <p>这之后，我们的绝大多数内容都会放在compiler.js中去实现Compiler这个类实现打包的核心流程。</p> <p>任何一次打包都需要入口文件，接下来让我们就从真正进入打包编译阶段。首当其冲的事情就是，我们需要根据入口配置文件路径寻找到对应入口文件。</p> <div class="language- extra-class"><pre class="language-text"><code>// compiler.js
const { SyncHook } = require('tapable');
const { toUnixPath } = require('./utils');

class Compiler {
  constructor(options) {
    this.options = options;
    // 相对路径跟路径 Context参数
    this.rootPath = this.options.context || toUnixPath(process.cwd());
    // 创建plugin hooks
    this.hooks = {
      // 开始编译时的钩子
      run: new SyncHook(),
      // 输出 asset 到 output 目录之前执行 (写入文件之前)
      emit: new SyncHook(),
      // 在 compilation 完成时执行 全部完成编译执行
      done: new SyncHook(),
    };
  }

  // run方法启动编译
  // 同时run方法接受外部传递的callback
  run(callback) {
    // 当调用run方式时 触发开始编译的plugin
    this.hooks.run.call();
    // 获取入口配置对象
    const entry = this.getEntry();
  }

  // 获取入口文件路径
  getEntry() {
    let entry = Object.create(null);
    const { entry: optionsEntry } = this.options;
    if (typeof optionsEntry === 'string') {
      entry['main'] = optionsEntry;
    } else {
      entry = optionsEntry;
    }
    // 将entry变成绝对路径
    Object.keys(entry).forEach((key) =&gt; {
      const value = entry[key];
      if (!path.isAbsolute(value)) {
        // 转化为绝对路径的同时统一路径分隔符为 /
        entry[key] = toUnixPath(path.join(this.rootPath, value));
      }
    });
    return entry;
  }
}

module.exports = Compiler;
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>// utils/index.js
/**
 *
 * 统一路径分隔符 主要是为了后续生成模块ID方便
 * @param {*} path
 * @returns
 */
function toUnixPath(path) {
  return path.replace(/\\/g, '/');
}
</code></pre></div><p>这一步我们通过options.entry处理获得入口文件的绝对路径。</p> <p>这里有几个需要注意的小点:</p> <ul><li>==this.hooks.run.call()==</li></ul> <p>在我们_loadePlugins函数中对于每一个传入的插件在compiler实例对象中进行了订阅，那么当我们调用run方法时，等于真正开始执行编译。这个阶段相当于我们需要告诉订阅者，发布开始执行的订阅。此时我们通过this.hooks.run.call()执行关于run的所有tap监听方法，从而触发对应的plugin逻辑。</p> <ul><li>==this.rootPath:==</li></ul> <p>在上述的外部webpack.config.js中我们配置了一个 context: process.cwd()，其实真实webpack中这个context值默认也是process.cwd()。</p> <p>关于它的详细解释你可以在这里看到<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Fentry-context%2F%23root" target="_blank" rel="noopener noreferrer">Context<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>简而言之，这个路径就是我们项目启动的目录路径，任何entry和loader中的相对路径都是针对于context这个参数的相对路径。</p> <p>这里我们使用this.rootPath在构造函数中来保存这个变量。</p> <ul><li>toUnixPath工具方法:</li></ul> <p>因为不同操作系统下，文件分隔路径是不同的。这里我们统一使用\来替换路径中的//来替换模块路径。后续我们会使用模块相对于rootPath的路径作为每一个文件的唯一ID，所以这里统一处理下路径分隔符。</p> <ul><li>entry的处理方法:</li></ul> <p>关于entry配置，webpack中其实有很多种。我们这里考虑了比较常见的两种配置方式:</p> <div class="language- extra-class"><pre class="language-text"><code>entry:'entry1.js'

// 本质上这段代码在webpack中会被转化为
entry: {
    main:'entry1.js
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>entry: {
   'entry1':'./entry1.js',
   'entry2':'/user/wepback/example/src/entry2.js'
}
</code></pre></div><p>这两种方式任何方式都会经过==getEntry==方法最终转化称为{ [模块名]:[模块绝对路径]... }的形式，关于geEntry()方法其实非常简单，这里我就不过于累赘这个方法的实现过程了。</p> <p>这一步，我们就通过==getEntry==方法获得了一个==key==为==entryName,value为entryAbsolutePath==的对象了，接来下就让我们从入口文件出发进行编译流程吧。</p> <h2 id="模块编译阶段"><a href="#模块编译阶段" class="header-anchor">#</a> 模块编译阶段</h2> <p>上边我们讲述了关于编译阶段的准备工作:</p> <ul><li>目录/文件基础逻辑补充。</li> <li>通过hooks.tap注册webpack插件。</li> <li>getEntry方法获得各个入口的对象。</li></ul> <p>接下来让我们继续完善compiler.js。</p> <p>在模块编译阶段，我们需要做的事件:</p> <ul><li>根据入口文件路径分析入口文件，对于入口文件进行匹配对应的loader进行处理入口文件。</li> <li>将loader处理完成的入口文件使用webpack进行编译。</li> <li>分析入口文件依赖，重复上边两个步骤编译对应依赖。</li> <li>如果嵌套文件存在依赖文件，递归调用依赖模块进行编译。</li> <li>递归编译完成后，组装一个个包含多个模块的chunk</li></ul> <p>首先，我们先来给compiler.js的构造函数中补充一下对应的逻辑:</p> <div class="language- extra-class"><pre class="language-text"><code>class Compiler {
  constructor(options) {
    this.options = options;
    // 创建plugin hooks
    this.hooks = {
      // 开始编译时的钩子
      run: new SyncHook(),
      // 输出 asset 到 output 目录之前执行 (写入文件之前)
      emit: new SyncHook(),
      // 在 compilation 完成时执行 全部完成编译执行
      done: new SyncHook(),
    };
    // 保存所有入口模块对象
    this.entries = new Set();
    // 保存所有依赖模块对象
    this.modules = new Set();
    // 所有的代码块对象
    this.chunks = new Set();
    // 存放本次产出的文件对象
    this.assets = new Set();
    // 存放本次编译所有产出的文件名
    this.files = new Set();
  }
  // ...
 }
</code></pre></div><p>这里我们通过给==compiler==构造函数中添加一些列属性来保存关于编译阶段生成的对应资源/模块对象。</p> <blockquote><p>关于entries\modules\chunks\assets\files这几个Set对象是贯穿我们核心打包流程的属性，它们各自用来储存编译阶段不同的资源从而最终通过对应的属性进行生成编译后的文件。</p></blockquote> <h3 id="根据入口文件路径分析入口文件"><a href="#根据入口文件路径分析入口文件" class="header-anchor">#</a> 根据入口文件路径分析入口文件</h3> <p>上边说到我们在run方法中已经可以通过this.getEntry();获得对应的入口对象了～
接下来就让我们从入口文件开始去分析入口文件吧！</p> <div class="language- extra-class"><pre class="language-text"><code>class Compiler {
    // run方法启动编译
  // 同时run方法接受外部传递的callback
  run(callback) {
    // 当调用run方式时 触发开始编译的plugin
    this.hooks.run.call();
    // 获取入口配置对象
    const entry = this.getEntry();
    // 编译入口文件
    this.buildEntryModule(entry);
  }

  buildEntryModule(entry) {
    Object.keys(entry).forEach((entryName) =&gt; {
      const entryPath = entry[entryName];
      const entryObj = this.buildModule(entryName, entryPath);
      this.entries.add(entryObj);
    });
  }
  
  
  // 模块编译方法
  buildModule(moduleName,modulePath) {
    // ...
    return {}
  }
}
</code></pre></div><p>这里我们添加了一个名为buildEntryModule方法作为入口模块编译方法。循环入口对象，得到每一个入口对象的名称和路径。</p> <blockquote><p>比如假使我们在开头传入entry:{ main:'./src/main.js' }的话，buildEntryModule获得的形参entry为{ main: &quot;/src...[你的绝对路径]&quot; }, 此时我们buildModule方法接受的entryName为main,entryPath为入口文件main对应的的绝对路径。</p></blockquote> <blockquote><p>单个入口编译完成后，我们会在buildModule方法中返回一个对象。这个对象就是我们编译入口文件后的对象。</p></blockquote> <h3 id="buildmodule模块编译方法"><a href="#buildmodule模块编译方法" class="header-anchor">#</a> buildModule模块编译方法</h3> <p>在进行代码编写之前，我们先来梳理一下buildModule方法它需要做哪些事情:</p> <ul><li><p>buildModule接受两个参数进行模块编译，<strong>第一个为模块所属的入口文件名称</strong>，第二个为需要编译的模块路径。</p></li> <li><p>buildModule方法要进行代码编译的前提就是，通过fs模块根据入口文件路径读取文件源代码。</p></li> <li><p>读取文件内容之后，调用所有匹配的loader对模块进行处理得到返回后的结果。</p></li> <li><p>得到loader处理后的结果后，通过babel分析loader处理后的代码，进行代码编译。(这一步编译主要是针对require语句，修改源代码中require语句的路径)。</p></li> <li><p>如果该入口文件没有依赖与任何模块(require语句)，那么返回编译后的模块对象。</p></li> <li><p>如果该入口文件存在依赖的模块，递归buildModule方法进行模块编译。</p></li></ul> <h4 id="读取文件内容"><a href="#读取文件内容" class="header-anchor">#</a> 读取文件内容</h4> <ol><li>我们先调用fs模块读取文件内容。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>const fs = require('fs');
// ...
class Compiler {
      //...
      // 模块编译方法
      buildModule(moduleName, modulePath) {
        // 1. 读取文件原始代码
        const originSourceCode =
          ((this.originSourceCode = fs.readFileSync(modulePath, 'utf-8'));
        // moduleCode为修改后的代码
        this.moduleCode = originSourceCode;
      }
      
      // ...
 }
</code></pre></div><h4 id="调用loader处理匹配后缀文件"><a href="#调用loader处理匹配后缀文件" class="header-anchor">#</a> 调用loader处理匹配后缀文件</h4> <ol start="2"><li>接下来我们获得了文件的具体内容之后，就需要匹配对应loader对我们的源代码进行编译了。</li></ol> <p>==<strong>实现简单自定义loader</strong>==
在进行loader编译前，我们先来实现一下我们上方传入的自定义loader吧。
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c08cd30dbb0b459f8441cf8b50c0bc84~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?" alt="image"></p> <p>webpack/loader目录下新建loader-1.js,loader-2.js:
首先我们需要清楚简单来说==loader本质上就是一个函数，接受我们的源代码作为入参同时返回处理后的结果==。</p> <blockquote><p>关于loader的特性，更加详细你可以在这里看到，因为文章主要讲述打包流程所以loader我们简单的作为倒序处理。更加具体的loader/plugin开发我会在后续的文章详细补充。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>// loader本质上就是一个函数，接受原始内容，返回转换后的内容。
function loader1(sourceCode) {
  console.log('join loader1');
  return sourceCode + `\n const loader1 = 'https://github.com/19Qingfeng'`;
}

module.exports = loader1;
复制代码
function loader2(sourceCode) {
  console.log('join loader2');
  return sourceCode + `\n const loader2 = '19Qingfeng'`;
}

module.exports = loader2;
</code></pre></div><p>==<strong>使用loader处理文件</strong>==
在搞清楚了loader就是一个单纯的函数之后，让我们在进行模块分析之前将内容先交给匹配的loader去处理下吧。</p> <div class="language- extra-class"><pre class="language-text"><code>// 模块编译方法
  buildModule(moduleName, modulePath) {
    // 1. 读取文件原始代码
    const originSourceCode =
      ((this.originSourceCode = fs.readFileSync(modulePath)), 'utf-8');
    // moduleCode为修改后的代码
    this.moduleCode = originSourceCode;
    //  2. 调用loader进行处理
    this.handleLoader(modulePath);
  }

  // 匹配loader处理
  handleLoader(modulePath) {
    const matchLoaders = [];
    // 1. 获取所有传入的loader规则
    const rules = this.options.module.rules;
    rules.forEach((loader) =&gt; {
      const testRule = loader.test;
      if (testRule.test(modulePath)) {
        if (loader.loader) {
          // 仅考虑loader { test:/\.js$/g, use:['babel-loader'] }, { test:/\.js$/, loader:'babel-loader' }
          matchLoaders.push(loader.loader);
        } else {
          matchLoaders.push(...loader.use);
        }
      }
      // 2. 倒序执行loader传入源代码
      for (let i = matchLoaders.length - 1; i &gt;= 0; i--) {
        // 目前我们外部仅支持传入绝对路径的loader模式
        // require引入对应loader
        const loaderFn = require(matchLoaders[i]);
        // 通过loader同步处理我的每一次编译的moduleCode
        this.moduleCode = loaderFn(this.moduleCode);
      }
    });
  }
</code></pre></div><p>这里我们通过handleLoader函数，对于传入的文件路径匹配到对应后缀的loader后，依次倒序执行loader处理我们的代码this.moduleCode并且同步更新每次moduleCode。</p> <p>最终，在每一个模块编译中this.moduleCode都会经过对应的loader处理。</p> <h4 id="webpack模块编译阶段"><a href="#webpack模块编译阶段" class="header-anchor">#</a> webpack模块编译阶段</h4> <p>上一步我们经历过loader处理了我们的入口文件代码，并且得到了处理后的代码保存在了this.moduleCode中。</p> <p>此时，经过loader处理后我们就要进入webpack内部的编译阶段了。</p> <p>这里我们需要做的是:<strong>针对当前模块进行编译，将当前模块所有依赖的模块(require())语句引入的路径变为相对于跟路径(this.rootPath)的相对路径</strong>。</p> <blockquote><p>总之你需要搞明白的是，我们这里编译的结果是期望将源代码中的依赖模块路径变为相对跟路径的路径，同时建立基础的模块依赖关系。后续我会告诉你为什么针对路径进行编译。</p></blockquote> <p>让我们继续来完善buildModule方法吧:</p> <div class="language- extra-class"><pre class="language-text"><code>const parser = require('@babel/parser');
const traverse = require('@babel/traverse').default;
const generator = require('@babel/generator').default;
const t = require('@babel/types');
const tryExtensions = require('./utils/index')
// ...
  class Compiler {
     // ...
      
     // 模块编译方法
      buildModule(moduleName, modulePath) {
        // 1. 读取文件原始代码
        const originSourceCode =
          ((this.originSourceCode = fs.readFileSync(modulePath)), 'utf-8');
        // moduleCode为修改后的代码
        this.moduleCode = originSourceCode;
        //  2. 调用loader进行处理
        this.handleLoader(modulePath);
        // 3. 调用webpack 进行模块编译 获得最终的module对象
        const module = this.handleWebpackCompiler(moduleName, modulePath);
        // 4. 返回对应module
        return module
      }

      // 调用webpack进行模块编译
      handleWebpackCompiler(moduleName, modulePath) {
        // 将当前模块相对于项目启动根目录计算出相对路径 作为模块ID
        const moduleId = './' + path.posix.relative(this.rootPath, modulePath);
        // 创建模块对象
        const module = {
          id: moduleId,
          dependencies: new Set(), // 该模块所依赖模块绝对路径地址
          name: [moduleName], // 该模块所属的入口文件
        };
        // 调用babel分析我们的代码
        const ast = parser.parse(this.moduleCode, {
          sourceType: 'module',
        });
        // 深度优先 遍历语法Tree
        traverse(ast, {
          // 当遇到require语句时
          CallExpression:(nodePath) =&gt; {
            const node = nodePath.node;
            if (node.callee.name === 'require') {
              // 获得源代码中引入模块相对路径
              const requirePath = node.arguments[0].value;
              // 寻找模块绝对路径 当前模块路径+require()对应相对路径
              const moduleDirName = path.posix.dirname(modulePath);
              const absolutePath = tryExtensions(
                path.posix.join(moduleDirName, requirePath),
                this.options.resolve.extensions,
                requirePath,
                moduleDirName
              );
              // 生成moduleId - 针对于跟路径的模块ID 添加进入新的依赖模块路径
              const moduleId =
                './' + path.posix.relative(this.rootPath, absolutePath);
              // 通过babel修改源代码中的require变成__webpack_require__语句
              node.callee = t.identifier('__webpack_require__');
              // 修改源代码中require语句引入的模块 全部修改变为相对于跟路径来处理
              node.arguments = [t.stringLiteral(moduleId)];
              // 为当前模块添加require语句造成的依赖(内容为相对于根路径的模块ID)
              module.dependencies.add(moduleId);
            }
          },
        });
        // 遍历结束根据AST生成新的代码
        const { code } = generator(ast);
        // 为当前模块挂载新的生成的代码
        module._source = code;
        // 返回当前模块对象
        return module
      }
  }
</code></pre></div><p>这一步我们关于webpack编译的阶段就完成了。</p> <p><strong>需要注意的是</strong>:</p> <ul><li><p>这里我们使用babel相关的API针对于require语句进行了编译，如果对于babel相关的api不太了解的朋友可以在前置知识中查看我的另两篇文章。这里我就不在累赘了</p></li> <li><p>同时我们代码中引用了一个tryExtensions()工具方法，这个方法是针对于后缀名不全的工具方法，稍后你就可以看到这个方法的具体内容。</p></li> <li><p>针对于每一次文件编译，我们都会返回一个module对象，这个对象是重中之重。</p> <ul><li>id属性，表示当前模块针对于this.rootPath的相对目录。</li> <li>dependencies属性，它是一个Set内部保存了该模块依赖的所有模块的模块ID。</li> <li>name属性,它表示该模块属于哪个入口文件。</li> <li>_source属性，它存放模块自身经过babel编译后的字符串代码。</li></ul></li></ul> <p>==<strong>tryExtensions方法实现</strong>==
我们在上文的webpack.config.js有这么一个配置：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d49f431c11e4d83a6ab46f54fefd6b5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?" alt="image"></p> <p>熟悉webpack配置的同学可能清楚，resolve.extensions是针对于引入依赖时，在没有书写文件后缀的情况下，webpack会自动帮我们按照传入的规则为文件添加后缀。</p> <p>在清楚了原理后我们来一起看看utils/tryExtensions方法的实现:</p> <div class="language- extra-class"><pre class="language-text"><code>/**
 *
 *
 * @param {*} modulePath 模块绝对路径
 * @param {*} extensions 扩展名数组
 * @param {*} originModulePath 原始引入模块路径
 * @param {*} moduleContext 模块上下文(当前模块所在目录)
 */
function tryExtensions(
  modulePath,
  extensions,
  originModulePath,
  moduleContext
) {
  // 优先尝试不需要扩展名选项
  extensions.unshift('');
  for (let extension of extensions) {
    if (fs.existsSync(modulePath + extension)) {
      return modulePath + extension;
    }
  }
  // 未匹配对应文件
  throw new Error(
    `No module, Error: Can't resolve ${originModulePath} in  ${moduleContext}`
  );
}
</code></pre></div><p>这个方法很简单，我们通过fs.existsSync检查传入文件结合extensions依次遍历寻找对应匹配的路径是否存在，如果找到则直接返回。如果未找到则给予用于一个友好的提示错误。</p> <blockquote><p>需要注意 extensions.unshift('');是防止用户如果已经传入了后缀时，我们优先尝试直接寻找，如果可以找到文件那么就直接返回。找不到的情况下才会依次尝试。</p></blockquote> <h4 id="递归处理"><a href="#递归处理" class="header-anchor">#</a> 递归处理</h4> <p>经过上一步处理，针对入口文件我们调用buildModule可以得到这样的返回对象。
我们先来看看运行webpack/core/index.js得到的返回结果吧。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6310bca0e92e4171a571e3bdf9ce727d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?" alt="image"></p> <p>我在buildEntryModule中打印了处理完成后的entries对象。可以看到正如我们之前所期待的:</p> <ul><li>id为每个模块相对于跟路径的模块.(这里我们配置的context:process.cwd())为webpack目录。</li> <li>dependencies为该模块内部依赖的模块，这里目前还没有添加。</li> <li>name为该模块所属的入口文件名称。</li> <li>_source为该模块编译后的源代码。</li></ul> <blockquote><p>目前_source中的内容是基于</p></blockquote> <p>此时让我们打开src目录为我们的两个入口文件添加一些依赖和内容吧:</p> <div class="language- extra-class"><pre class="language-text"><code>// webpack/example/entry1.js
const depModule = require('./module');

console.log(depModule, 'dep');
console.log('This is entry 1 !');


// webpack/example/entry2.js
const depModule = require('./module');

console.log(depModule, 'dep');
console.log('This is entry 2 !');

// webpack/example/module.js
const name = '19Qingfeng';

module.exports = {
  name,
};
</code></pre></div><p>此时让我们重新运行webpack/core/index.js:
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00e33c57d8d243c68d6bddfc64fbea37~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?" alt="image"></p> <p>OK，目前为止我们针对于entry的编译可以暂时告一段落了。</p> <p><strong>总之也就是，这一步我们通过``方法将entry进行分析编译后得到一个对象。将这个对象添加到this.entries中去</strong>。</p> <p>接下来让我们去处理依赖的模块吧。</p> <p>其实对于依赖的模块无非也是相同的步骤：</p> <ul><li>检查入口文件中是否存在依赖。</li> <li>存在依赖的话，递归调用buildModule方法编译模块。传入moduleName为当前模块所属的入口文件。modulePath为当前被依赖模块的绝对路径。</li> <li>同理检查递归检查被依赖的模块内部是否仍然存在依赖，存在的话递归依赖进行模块编译。这是一个深度优先的过程。</li> <li>将每一个编译后的模块保存进入this.modules中去。</li></ul> <p>接下来我们只要稍稍在handleWebpackCompiler方法中稍稍改动就可以了:</p> <div class="language- extra-class"><pre class="language-text"><code>// 调用webpack进行模块编译
  handleWebpackCompiler(moduleName, modulePath) {
    // 将当前模块相对于项目启动根目录计算出相对路径 作为模块ID
    const moduleId = './' + path.posix.relative(this.rootPath, modulePath);
    // 创建模块对象
    const module = {
      id: moduleId,
      dependencies: new Set(), // 该模块所依赖模块绝对路径地址
      name: [moduleName], // 该模块所属的入口文件
    };
    // 调用babel分析我们的代码
    const ast = parser.parse(this.moduleCode, {
      sourceType: 'module',
    });
    // 深度优先 遍历语法Tree
    traverse(ast, {
      // 当遇到require语句时
      CallExpression: (nodePath) =&gt; {
        const node = nodePath.node;
        if (node.callee.name === 'require') {
          // 获得源代码中引入模块相对路径
          const requirePath = node.arguments[0].value;
          // 寻找模块绝对路径 当前模块路径+require()对应相对路径
          const moduleDirName = path.posix.dirname(requirePath);
          const absolutePath = tryExtensions(
            path.posix.join(moduleDirName, requirePath),
            this.options.resolve.extensions,
            moduleName,
            moduleDirName
          );
          // 生成moduleId - 针对于跟路径的模块ID 添加进入新的依赖模块路径
          const moduleId =
            './' + path.posix.relative(this.rootPath, absolutePath);
          // 通过babel修改源代码中的require变成__webpack_require__语句
          node.callee = t.identifier('__webpack_require__');
          // 修改源代码中require语句引入的模块 全部修改变为相对于跟路径来处理
          node.arguments = [t.stringLiteral(moduleId)];
          // 为当前模块添加require语句造成的依赖(内容为相对于根路径的模块ID)
          module.dependencies.add(moduleId);
        }
      },
    });
    // 遍历结束根据AST生成新的代码
    const { code } = generator(ast);
    // 为当前模块挂载新的生成的代码
    module._source = code;
    // 递归依赖深度遍历 存在依赖模块则加入
    module.dependencies.forEach((dependency) =&gt; {
      const depModule = this.buildModule(moduleName, dependency);
      // 将编译后的任何依赖模块对象加入到modules对象中去
      this.modules.add(depModule);
    });
    // 返回当前模块对象
    return module;
  }
</code></pre></div><p>这里我们添加了这样一段代码:</p> <div class="language- extra-class"><pre class="language-text"><code>// 递归依赖深度遍历 存在依赖模块则加入
    module.dependencies.forEach((dependency) =&gt; {
      const depModule = this.buildModule(moduleName, dependency);
      // 将编译后的任何依赖模块对象加入到modules对象中去
      this.modules.add(depModule);
    });
</code></pre></div><p>这里我们对于依赖的模块进行了递归调用buildModule,将输出的模块对象添加进入了this.modules中去。
此时让我们重新运行webpack/core/index.js进行编译，这里我在buildEntryModule编译结束后打印了assets和modules:
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5b1eb97de7c44919ab8f57635d3ab13~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?" alt="image"></p> <div class="language- extra-class"><pre class="language-text"><code>Set {
  {
    id: './example/src/entry1.js',
    dependencies: Set { './example/src/module.js' },
    name: [ 'main' ],
    _source: 'const depModule = __webpack_require__(&quot;./example/src/module.js&quot;);\n' +
      '\n' +
      &quot;console.log(depModule, 'dep');\n&quot; +
      &quot;console.log('This is entry 1 !');\n&quot; +
      &quot;const loader2 = '19Qingfeng';\n&quot; +
      &quot;const loader1 = 'https://github.com/19Qingfeng';&quot;
  },
  {
    id: './example/src/entry2.js',
    dependencies: Set { './example/src/module.js' },
    name: [ 'second' ],
    _source: 'const depModule = __webpack_require__(&quot;./example/src/module.js&quot;);\n' +
      '\n' +
      &quot;console.log(depModule, 'dep');\n&quot; +
      &quot;console.log('This is entry 2 !');\n&quot; +
      &quot;const loader2 = '19Qingfeng';\n&quot; +
      &quot;const loader1 = 'https://github.com/19Qingfeng';&quot;
  }
} entries
Set {
  {
    id: './example/src/module.js',
    dependencies: Set {},
    name: [ 'main' ],
    _source: &quot;const name = '19Qingfeng';\n&quot; +
      'module.exports = {\n' +
      '  name\n' +
      '};\n' +
      &quot;const loader2 = '19Qingfeng';\n&quot; +
      &quot;const loader1 = 'https://github.com/19Qingfeng';&quot;
  },
  {
    id: './example/src/module.js',
    dependencies: Set {},
    name: [ 'second' ],
    _source: &quot;const name = '19Qingfeng';\n&quot; +
      'module.exports = {\n' +
      '  name\n' +
      '};\n' +
      &quot;const loader2 = '19Qingfeng';\n&quot; +
      &quot;const loader1 = 'https://github.com/19Qingfeng';&quot;
  }
} modules
</code></pre></div><p>可以看到我们已经将module.js这个依赖如愿以偿加入到modules中了，同时它也经过loader的处理。但是我们发现它被重复加入了两次。</p> <p>这是因为module.js这个模块被引用了两次，它被entry1和entry2都已进行了依赖，在进行递归编译时我们进行了两次buildModule相同模块。</p> <p>让我们来处理下这个问题:</p> <div class="language- extra-class"><pre class="language-text"><code>handleWebpackCompiler(moduleName, modulePath) {
       ...
        // 通过babel修改源代码中的require变成__webpack_require__语句
          node.callee = t.identifier('__webpack_require__');
          // 修改源代码中require语句引入的模块 全部修改变为相对于跟路径来处理
          node.arguments = [t.stringLiteral(moduleId)];
          // 转化为ids的数组 好处理
          const alreadyModules = Array.from(this.modules).map((i) =&gt; i.id);
          if (!alreadyModules.includes(moduleId)) {
            // 为当前模块添加require语句造成的依赖(内容为相对于根路径的模块ID)
            module.dependencies.add(moduleId);
          } else {
            // 已经存在的话 虽然不进行添加进入模块编译 但是仍要更新这个模块依赖的入口
            this.modules.forEach((value) =&gt; {
              if (value.id === moduleId) {
                value.name.push(moduleName);
              }
            });
          }
        }
      },
    });
    ...
    }
</code></pre></div><p>这里在每一次代码分析的依赖转化中，首先判断this.module对象是否已经存在当前模块了（通过唯一的模块id路径判断）。</p> <p>如果不存在则添加进入依赖中进行编译，如果该模块已经存在过了就证明这个模块已经被编译过了。所以此时我们不需要将它再次进行编译，我们仅仅需要更新这个模块所属的chunk，为它的name属性添加当前所属的chunk名称。</p> <p>重新运行，让我们在来看看打印结果:</p> <div class="language- extra-class"><pre class="language-text"><code>Set(2) {
  {
    id: './example/src/entry1.js',
    dependencies: Set(1) { './example/src/module.js' },
    name: [ 'main' ],
    _source: 'const depModule = __webpack_require__(&quot;./example/src/module.js&quot;);\n' +
      '\n' +
      &quot;console.log(depModule, 'dep');\n&quot; +
      &quot;console.log('This is entry 1 !');\n&quot; +
      &quot;const loader2 = '19Qingfeng';\n&quot; +
      &quot;const loader1 = 'https://github.com/19Qingfeng';&quot;
  },
  {
    id: './example/src/entry2.js',
    dependencies: Set(0) {},
    name: [ 'second' ],
    _source: 'const depModule = __webpack_require__(&quot;./example/src/module.js&quot;);\n' +
      '\n' +
      &quot;console.log(depModule, 'dep');\n&quot; +
      &quot;console.log('This is entry 2 !');\n&quot; +
      &quot;const loader2 = '19Qingfeng';\n&quot; +
      &quot;const loader1 = 'https://github.com/19Qingfeng';&quot;
  }
} 入口文件
Set(1) {
  {
    id: './example/src/module.js',
    dependencies: Set(0) {},
    name: [ 'main', 'second' ],
    _source: &quot;const name = '19Qingfeng';\n&quot; +
      'module.exports = {\n' +
      '  name\n' +
      '};\n' +
      &quot;const loader2 = '19Qingfeng';\n&quot; +
      &quot;const loader1 = 'https://github.com/19Qingfeng';&quot;
  }
} modules
</code></pre></div><p>此时针对我们的“模块编译阶段”基本已经结束了，这一步我们对于所有模块从入口文件开始进行分析。</p> <ul><li>从入口出发，读取入口文件内容调用匹配loader处理入口文件。</li> <li>通过babel分析依赖，并且同时将所有依赖的路径更换为相对于项目启动目录options.context的路径。</li> <li>入口文件中如果存在依赖的话，递归上述步骤编译依赖模块。</li> <li>将每个依赖的模块编译后的对象加入this.modules。</li> <li>将每个入口文件编译后的对象加入this.entries。</li></ul> <h2 id="编译完成阶段"><a href="#编译完成阶段" class="header-anchor">#</a> 编译完成阶段</h2> <p>在上一步我们完成了模块之间的编译，并且为module和entry分别填充了内容。</p> <p>在将所有模块递归编译完成后，我们需要根据上述的依赖关系，组合最终输出的chunk模块。</p> <p>让我们来继续改造我们的Compiler吧:</p> <div class="language- extra-class"><pre class="language-text"><code>class Compiler {

    // ...
    buildEntryModule(entry) {
        Object.keys(entry).forEach((entryName) =&gt; {
          const entryPath = entry[entryName];
          // 调用buildModule实现真正的模块编译逻辑
          const entryObj = this.buildModule(entryName, entryPath);
          this.entries.add(entryObj);
          // 根据当前入口文件和模块的相互依赖关系，组装成为一个个包含当前入口所有依赖模块的chunk
          this.buildUpChunk(entryName, entryObj);
        });
        console.log(this.chunks, 'chunks');
    }
    
     // 根据入口文件和依赖模块组装chunks
      buildUpChunk(entryName, entryObj) {
        const chunk = {
          name: entryName, // 每一个入口文件作为一个chunk
          entryModule: entryObj, // entry编译后的对象
          modules: Array.from(this.modules).filter((i) =&gt;
            i.name.includes(entryName)
          ), // 寻找与当前entry有关的所有module
        };
        // 将chunk添加到this.chunks中去
        this.chunks.add(chunk);
      }
      
      // ...
}
</code></pre></div><p>这里，我们根据对应的入口文件通过每一个模块(module)的name属性查找对应入口的所有依赖文件。</p> <p>我们先来看看this.chunks最终会输出什么:</p> <div class="language- extra-class"><pre class="language-text"><code>Set {
  {
    name: 'main',
    entryModule: {
      id: './example/src/entry1.js',
      dependencies: [Set],
      name: [Array],
      _source: 'const depModule = __webpack_require__(&quot;./example/src/module.js&quot;);\n' +
        '\n' +
        &quot;console.log(depModule, 'dep');\n&quot; +
        &quot;console.log('This is entry 1 !');\n&quot; +
        &quot;const loader2 = '19Qingfeng';\n&quot; +
        &quot;const loader1 = 'https://github.com/19Qingfeng';&quot;
    },
    modules: [ [Object] ]
  },
  {
    name: 'second',
    entryModule: {
      id: './example/src/entry2.js',
      dependencies: Set {},
      name: [Array],
      _source: 'const depModule = __webpack_require__(&quot;./example/src/module.js&quot;);\n' +
        '\n' +
        &quot;console.log(depModule, 'dep');\n&quot; +
        &quot;console.log('This is entry 2 !');\n&quot; +
        &quot;const loader2 = '19Qingfeng';\n&quot; +
        &quot;const loader1 = 'https://github.com/19Qingfeng';&quot;
    },
    modules: []
  }
}
</code></pre></div><p>这一步，我们得到了Webpack中最终输出的两个chunk。
它们分别拥有:</p> <ul><li>name:当前入口文件的名称</li> <li>entryModule: 入口文件编译后的对象。</li> <li>modules: 该入口文件依赖的所有模块对象组成的数组，其中每一个元素的格式和entryModule是一致的。</li></ul> <p>此时编译完成我们拼装chunk的环节就圆满完成。</p> <h2 id="输出文件阶段"><a href="#输出文件阶段" class="header-anchor">#</a> 输出文件阶段</h2> <p>我们先放一下上一步所有编译完成后拼装出来的this.chunks。</p> <h3 id="分析原始打包输出结果"><a href="#分析原始打包输出结果" class="header-anchor">#</a> 分析原始打包输出结果</h3> <p>这里，我把webpack/core/index.js中做了如下修改:</p> <div class="language- extra-class"><pre class="language-text"><code>- const webpack = require('./webpack');
+ const webpack = require('webpack')

...
</code></pre></div><p>运用原本的webpack代替我们自己实现的webpack先进行一次打包。</p> <p>运行webpack/core/index.js后，我们会在webpack/src/build中得到两个文件:main.js和second.js,我们以其中一个main.js来看看它的内容:</p> <div class="language- extra-class"><pre class="language-text"><code>(() =&gt; {
  var __webpack_modules__ = {
    './example/src/module.js': (module) =&gt; {
      const name = '19Qingfeng';

      module.exports = {
        name,
      };

      const loader2 = '19Qingfeng';
      const loader1 = 'https://github.com/19Qingfeng';
    },
  };
  // The module cache
  var __webpack_module_cache__ = {};

  // The require function
  function __webpack_require__(moduleId) {
    // Check if module is in cache
    var cachedModule = __webpack_module_cache__[moduleId];
    if (cachedModule !== undefined) {
      return cachedModule.exports;
    }
    // Create a new module (and put it into the cache)
    var module = (__webpack_module_cache__[moduleId] = {
      // no module.id needed
      // no module.loaded needed
      exports: {},
    });

    // Execute the module function
    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);

    // Return the exports of the module
    return module.exports;
  }

  var __webpack_exports__ = {};
  // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
  (() =&gt; {
    const depModule = __webpack_require__(
      /*! ./module */ './example/src/module.js'
    );

    console.log(depModule, 'dep');
    console.log('This is entry 1 !');

    const loader2 = '19Qingfeng';
    const loader1 = 'https://github.com/19Qingfeng';
  })();
})();

</code></pre></div><blockquote><p>这里我手动删除了打包生成后的多余注释，精简了代码。</p></blockquote> <p>我们来稍微分析一下原始打包生成的代码：</p> <p>webpack打包后的代码内部定义了一个__webpack_require__的函数代替了NodeJs内部的require方法。
同时底部的
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28cda8e5306548d3925a4e36b8547b62~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?" alt="image"></p> <p>这块代码相比大家都很熟悉吧，这就是我们编译后的入口文件代码。同时顶部的代码是该入口文件依赖的所有模块定义的一个对象:</p> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78f606cc93cd4773befe0d7589f75217~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?" alt="image"></p> <p>这里定义了一个__webpack__modules的对象，**对象的key为该依赖模块相对于跟路径的相对路径，对象的value该依赖模块编译后的代码。`</p> <h3 id="输出文件阶段-2"><a href="#输出文件阶段-2" class="header-anchor">#</a> 输出文件阶段</h3> <p>接下里在分析完webpack原始打包后的代码之后，上我们来继续上一步。通过我们的this.chunks来尝试输出最终的效果吧。</p> <p>让我们回到Compiler上的run方法中:</p> <div class="language- extra-class"><pre class="language-text"><code>class Compiler {
   
   }
  // run方法启动编译
  // 同时run方法接受外部传递的callback
  run(callback) {
    // 当调用run方式时 触发开始编译的plugin
    this.hooks.run.call();
    // 获取入口配置对象
    const entry = this.getEntry();
    // 编译入口文件
    this.buildEntryModule(entry);
    // 导出列表;之后将每个chunk转化称为单独的文件加入到输出列表assets中
    this.exportFile(callback);
  }
</code></pre></div><p>我们在buildEntryModule模块编译完成之后，通过this.exportFile方法实现导出文件的逻辑。
让我们来一起看看this.exportFile方法:</p> <div class="language- extra-class"><pre class="language-text"><code>// 将chunk加入输出列表中去
  exportFile(callback) {
    const output = this.options.output;
    // 根据chunks生成assets内容
    this.chunks.forEach((chunk) =&gt; {
      const parseFileName = output.filename.replace('[name]', chunk.name);
      // assets中 { 'main.js': '生成的字符串代码...' }
      this.assets[parseFileName] = getSourceCode(chunk);
    });
    // 调用Plugin emit钩子
    this.hooks.emit.call();
    // 先判断目录是否存在 存在直接fs.write 不存在则首先创建
    if (!fs.existsSync(output.path)) {
      fs.mkdirSync(output.path);
    }
    // files中保存所有的生成文件名
    this.files = Object.keys(this.assets);
    // 将assets中的内容生成打包文件 写入文件系统中
    Object.keys(this.assets).forEach((fileName) =&gt; {
      const filePath = path.join(output.path, fileName);
      fs.writeFileSync(filePath, this.assets[fileName]);
    });
    // 结束之后触发钩子
    this.hooks.done.call();
    callback(null, {
      toJson: () =&gt; {
        return {
          entries: this.entries,
          modules: this.modules,
          files: this.files,
          chunks: this.chunks,
          assets: this.assets,
        };
      },
    });
  }
</code></pre></div><p>exportFile做了如下几件事:</p> <ul><li><p>首先获取配置参数的输出配置，迭代我们的this.chunks，将output.filename中的[name]替换称为对应的入口文件名称。同时根据chunks的内容为this.assets中添加需要打包生成的文件名和文件内容。</p></li> <li><p>将文件写入磁盘前调用plugin的emit钩子函数。</p></li> <li><p>判断output.path文件夹是否存在，如果不存在，则通过fs新建这个文件夹。</p></li> <li><p>将本次打包生成的所有文件名(this.assets的key值组成的数组)存放进入files中去。</p></li> <li><p>循环this.assets，将文件依次写入对应的磁盘中去。</p></li> <li><p>所有打包流程结束，触发webpack插件的done钩子。</p></li> <li><p>同时为NodeJs Webpack APi呼应，调用run方法中外部传入的callback传入两个参数。</p></li></ul> <p>总的来说，this.assets做的事情也比较简单，就是通过分析chunks得到assets然后输出对应的代码到磁盘中。</p> <p>仔细看过上边代码，你会发现。this.assets这个Map中每一个元素的value是通过调用getSourceCode(chunk)方法来生成模块对应的代码的。</p> <p>那么getSourceCode这个方法是如何根据chunk来生成我们最终编译后的代码呢？让我们一起来看看吧！</p> <h3 id="getsourcecode方法"><a href="#getsourcecode方法" class="header-anchor">#</a> getSourceCode方法</h3> <p>首先我们来简单明确一下这个方法的职责，我们需要getSourceCode方法接受传入的chunk对象。从而返回该chunk的源代码。</p> <p>废话不多说，其实这里我用了一个比较偷懒的办法，但是完全不妨碍你理解Webpack流程，上边我们分析过原本webpack打包后的代码仅仅只有入口文件和模块依赖是每次打包不同的地方，关于require方法之类都是相通的。</p> <p>把握每次的不同点，我们直接先来看看它的实现方式:</p> <div class="language- extra-class"><pre class="language-text"><code>// webpack/utils/index.js

...


/**
 *
 *
 * @param {*} chunk
 * name属性入口文件名称
 * entryModule入口文件module对象
 * modules 依赖模块路径
 */
function getSourceCode(chunk) {
  const { name, entryModule, modules } = chunk;
  return `
  (() =&gt; {
    var __webpack_modules__ = {
      ${modules
        .map((module) =&gt; {
          return `
          '${module.id}': (module) =&gt; {
            ${module._source}
      }
        `;
        })
        .join(',')}
    };
    // The module cache
    var __webpack_module_cache__ = {};

    // The require function
    function __webpack_require__(moduleId) {
      // Check if module is in cache
      var cachedModule = __webpack_module_cache__[moduleId];
      if (cachedModule !== undefined) {
        return cachedModule.exports;
      }
      // Create a new module (and put it into the cache)
      var module = (__webpack_module_cache__[moduleId] = {
        // no module.id needed
        // no module.loaded needed
        exports: {},
      });

      // Execute the module function
      __webpack_modules__[moduleId](module, module.exports, __webpack_require__);

      // Return the exports of the module
      return module.exports;
    }

    var __webpack_exports__ = {};
    // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
    (() =&gt; {
      ${entryModule._source}
    })();
  })();
  `;
}
...

</code></pre></div><p>这段代码其实非常非常简单，远远没有你想象的多难！有点返璞归真的感觉是吗哈哈。</p> <p>在getSourceCode方法中，我们通过组合而来的chunk获得对应的:</p> <ul><li>name: 该入口文件对应输出文件的名称。</li> <li>entryModule: 存放该入口文件编译后的对象。</li> <li>modules:存放该入口文件依赖的所有模块的对象。</li></ul> <p><strong>我们通过字符串拼接的方式去实现了__webpack__modules对象上的属性，同时也在底部通过${entryModule._source}拼接出入口文件的代码。</strong></p> <blockquote><p>这里我们上文提到过为什么要将模块的require方法的路径转化为相对于跟路径(context)的路径，看到这里我相信为什么这么做大家都已经了然于胸了。因为我们最终实现的__webpack_require__方法全都是针对于模块跟路径的相对路径自己实现的require方法。</p></blockquote> <blockquote><p>同时如果不太清楚require方法是如何转变称为__webpack_require__方法的同学可以重新回到我们的编译章节仔细复习熬～我们通过babel在AST转化阶段将require方法调用变成了__webpack_require__。</p></blockquote> <h2 id="大功告成"><a href="#大功告成" class="header-anchor">#</a> 大功告成</h2> <p>至此，让我们回到webpack/core/index.js中去。重新运行这个文件，你会发现webpack/example目录下会多出一个build目录。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5ec0529023c4b89a1cd2900d4dd8d5b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?" alt="image"></p> <p>这一步我们就完美的实现属于我们自己的webpack。</p> <p>实质上，我们对于实现一个简单版的webpack核心我还是希望大家可以在理解它的工作流的同时彻底理解compiler这个对象。</p> <p>在之后的任何关于webpack相关底层开发中，真正做到对于compiler的用法了然于胸。了解compiler上的各种属性是如何影响到编译打包结果的。</p> <p>让我们用一张流程图来进行一个完美的收尾吧:
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/851da6ae496d45b29e3897bd8282b691~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?" alt="image"></p> <h2 id="写在最后"><a href="#写在最后" class="header-anchor">#</a> 写在最后</h2> <p>首先，感谢每一位可以看到这里的同学。</p> <p>这篇文章相对有一定的知识门槛并且代码部分居多，敬佩每一位可以读到结尾的同学。</p> <p>文章中对于实现一个简易版的Webpack在这里就要和大家告一段落了，这其实只是一个最基础版本的webpack工作流。
但是正是通过这样一个小🌰可以带我们真正入门webpack的核心工作流，希望这篇文章对于大家理解webpack时可以起到更好的辅助作用。</p> <p>其实在理解清楚基础的工作流之后，针对于loader和plugin开发都是信手拈来的部分，文章中对于这两部分内容的开发介绍比较肤浅，后续我会分别更新有关loader和plugin的详细开发流程。有兴趣的同学可以及时关注😄。</p> <p>文章中的代码你可以在这里下载，这份简易版的webpack我也会持续在代码库中完善更多工作流的逻辑处理。</p> <p>同时这里这里的代码我想强调的是源码流程的讲解，真实的webpack会比这里复杂很多很多。这里为了方便大家理解刻意进行了简化，但是核心工作流是和源码中基本一致的。</p> <blockquote><p>转自：https://juejin.cn/post/7031546400034947108#heading-0</p></blockquote></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:0;" data-v-cb1513f6></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.6fe35129.js" defer></script><script src="/assets/js/3.c61b2de1.js" defer></script><script src="/assets/js/1.92ef6ebe.js" defer></script><script src="/assets/js/20.adcd6122.js" defer></script>
  </body>
</html>
