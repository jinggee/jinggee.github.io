(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{574:function(n,a,o){"use strict";o.r(a);var t=o(13),s=Object(t.a)({},(function(){var n=this,a=n.$createElement,o=n._self._c||a;return o("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[o("blockquote",[o("p",[n._v("this是JavaScript中最复杂的机制之一。它是一个很特别的关键字，被自动定义在所有函数的作用域中。")])]),n._v(" "),o("h3",{attrs:{id:"一、this到底指向什么"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#一、this到底指向什么"}},[n._v("#")]),n._v(" 一、this到底指向什么？")]),n._v(" "),o("p",[n._v("this既不指向函数自身，也不指向函数的词法作用域，具体指向什么，取决于你是怎么调用函数。")]),n._v(" "),o("ol",[o("li",[o("strong",[n._v("直接使用不带任何修饰的函数引用进行调用（即：方法名 + 括号）， this指向全局对象（非严格模式）或者undefined（严格模式），")]),n._v(" 这种绑定称为默认绑定\n")])]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("function foo() {\n    console.log(this.a);\n}\nvar a = 2;\nfoo();  // 2\n")])])]),o("p",[n._v("严格模式：")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v('function foo() {\n    "use strict"\n    console.log(this.a);\n}\nvar a = 2;\nfoo();  // undefiend\n')])])]),o("ol",{attrs:{start:"2"}},[o("li",[o("strong",[n._v("如果方法是某个对象的一个属性，通过该对象调用方法（即调用位置存在上下文对象），则this指向该对象，")]),n._v(" 这种绑定称为隐式绑定.")])]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("function foo() {\n    console.log(this.a);\n}\nvar obj = {\n    a: 2,\n    foo: foo\n}\nobj.foo();  // 2\n")])])]),o("p",[n._v("注意事项")]),n._v(" "),o("ul",[o("li",[n._v("如果多个对象之间形成了引用链，方法中的this指向其最顶层或者最后一层对象。")])]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("function foo() {\n    console.log(this.a);\n}\nvar obj1 = {\n    a: 42,\n    foo: foo\n}\n\nvar obj2 = {\n    a: 3,\n    obj1: obj1\n}\nobj2.obj1.foo() // 42\n")])])]),o("ul",[o("li",[n._v("隐式丢失，被隐式绑定的函数会丢失绑定对象，也即会应用默认绑定，从而把this绑定到全局对象或者undefined上。\n这种情况常出现在回调函数上：")])]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v('function foo() {\n    console.log(this.a);\n}\nfunction doFoo(fn) {\n    // fn 其实引用的是foo\n    fn();\n}\nvar obj = {\n    a: 2,\n    foo: foo\n}\nvar a = "oops, global";\n\ndoFoo(obj.foo)      // 输出"oops, global"\n')])])]),o("ol",{attrs:{start:"3"}},[o("li",[o("p",[o("strong",[n._v("使用call, apply方法调该函数时，this指向call,apply方法所传入的对象")]),n._v("，这种方式成为显示绑定")]),n._v(" "),o("p",[n._v("js中几乎所有的函数都有call()和apply()方法，这两个方法的第一个参数是一个对象，他们会把这个对象绑定到this.")])])]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("function foo() {\n    console.log(this.a);\n}\nvar obj = {\n    a: 2,\n}\nfoo.call(obj);      // 2\n")])])]),o("p",[n._v("显示绑定仍然存在绑定丢失的问题：例如")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v('function foo() {\n\tconsole.log(this.a);\n}\nfunction doFoo(fn) {\n\tfn();\n}\nvar obj = {\n\ta: 2,\n}\nvar a = "oops, global";\n\ndoFoo.call(obj, foo);   // 输出oops, global\n')])])]),o("p",[n._v("解决办法：")]),n._v(" "),o("ul",[o("li",[n._v("++硬绑定++\n在doFoo函数内，直接绑定obj对象")])]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("function doFoo(fn) {\n    fn.call(obj);\n}\n")])])]),o("p",[n._v("硬绑定一种常见的应用常见是创建一个可重复使用的辅助函数")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("function foo(something) {\n    console.log(this.a, something);\n    return this.a + something;\n}\n// 简单的辅助绑定函数\nfunction bind(fn, obj) {\n    return function() {\n        return fn.apply(obj, arguments);\n    }\n}\nvar obj = {a:2};\nvar bar = bind(foo, obj);\nvar b = bar(3); // 输出2 3\nconsole.log(b); // 输出5\n")])])]),o("p",[n._v("ES5中提供了内置的硬绑定的方法： Function.prototype.bind, 用法如下：")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("function foo(something) {\n    console.log(this.a, something);\n    return this.a + something;\n}\nvar obj = {\n    a:2;\n}\nvar bar = foo.bind(obj);\nvar b = bar(3);  // 2 3\nconsole.log(b);  // 5\n")])])]),o("p",[n._v("bind(..) 会返回一个硬编码的新函数，它会把参数设置为 this的上下文并调用原始函数。\n4. "),o("strong",[n._v("new绑定")])]),n._v(" "),o("p",[n._v("在javascript中，所有的函数都可以用new来调用，这种函数调用被称为构造函数调用。使用new来调用函数时，会自动执行下面操作：")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[n._v("1. 创建一个全新的对象;\n2. 这个新对象会被执行[[原型]链接;\n3. 这个新对象会绑定到函数调用的this\n4. 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象\n")])])]),o("p",[n._v("示例：")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("function foo(a) {\n    this.a = a; // 在这里，this绑定到bar对象\n}\nvar bar = new foo(2);\nconsole.log(bar.a);     // 2\n")])])]),o("h3",{attrs:{id:"二、如果函数调用时-既满足隐式绑定、又满足显示绑定或new绑定-该怎么办"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#二、如果函数调用时-既满足隐式绑定、又满足显示绑定或new绑定-该怎么办"}},[n._v("#")]),n._v(" 二、如果函数调用时，既满足隐式绑定、又满足显示绑定或new绑定，该怎么办？")]),n._v(" "),o("p",[n._v("new绑定优先级  >  显示绑定   >   隐式绑定 > 默认绑定")]),n._v(" "),o("ul",[o("li",[n._v("比较显示绑定和隐式绑定，new绑定和隐式绑定")])]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("function foo(something) {\n    this.a = something;\n}\nvar obj1 = {foo: foo};\nvar obj2 = {};\n\nobj1.foo.call(obj2, 3);     // foo函数的调用同时出现了隐式绑定和显示绑定，则显示绑定优先，this指向 obj2\nconsole.log(obj2.a);        // obj2.a = 3\n\nvar bar = new obj1.foo(4);  // 同时出现了隐式绑定和new绑定， this指向new绑定创建的对象bar, 而不是obj1\nconsole.log(bar.a);         // 输出4\n")])])]),o("ul",[o("li",[n._v("比较new绑定和显示绑定：")])]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("function foo(something) {\n    this.a = something;\n}\nvar obj1 = {};\n\nvar bar = foo.bind( obj1 );\n\nbar( 2 );\n\nconsole.log( obj1.a ); // 2\n\nvar baz = new bar(3);\n\nconsole.log( obj1.a ); // 2\n\nconsole.log( baz.a ); // 3\n")])])]),o("p",[n._v("bar 被硬绑定到 obj1 上，但是 new bar(3) 并没有像我们预计的那样把 obj1.a\n修改为 3。相反， new 修改了硬绑定（到 obj1 的）调用 bar(..) 中的 this")]),n._v(" "),o("h3",{attrs:{id:"三、特殊情况"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#三、特殊情况"}},[n._v("#")]),n._v(" 三、特殊情况")]),n._v(" "),o("ol",[o("li",[n._v("调用call或者apply时，参数传入null或者undefined， 此时this会采用默认绑定")])]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("function foo() {\n    console.log(this.a);\n}\nvar a = 2;\nfoo.call(null); // 输出2\n")])])]),o("ol",{attrs:{start:"2"}},[o("li",[n._v("函数的间接引用，此时this采用默认绑定。间接引用最常在赋值时发生：")])]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("function foo() {\n    console.log(this.a);\n}\n\nvar a = 2;\nvar o = { a: 3, foo: foo };\nvar p = { a: 4 };\no.foo(); // 3\n(p.foo = o.foo)(); // 2\n")])])]),o("p",[n._v("赋值表达式 p.foo = o.foo 的返回值是目标函数的引用，因此调用位置是 foo() 而不是p.foo() 或者 o.foo()")]),n._v(" "),o("ol",{attrs:{start:"3"}},[o("li",[o("strong",[n._v("箭头函数")])])]),n._v(" "),o("p",[n._v("前面提到的四种绑定规则对箭头函数不适用，箭头函数中的this是根据外层作用域来决定的。")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("function foo() {\n    return (a) => {\n        console.log(this.a);\n    }\n}\n\nvar obj1 = {a:2};\nvar obj2 = {a:3};\n\nvar bar = foo.call(obj1); // 箭头函数的外层作用域中的this指向 obj1, 所以箭头函数中this也指向obj1，箭头函数的绑定无法被修改\nbar.call(obj2);     // 输出2，\n")])])]),o("h3",{attrs:{id:"四、-小结"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#四、-小结"}},[n._v("#")]),n._v(" 四、 小结")]),n._v(" "),o("p",[n._v("判断一个运行中函数的this绑定，就需要找到这个函数的直接调用位置，找到后就可以顺序应用这四条规则判断this的绑定对象。")]),n._v(" "),o("ol",[o("li",[n._v("由new调用？ 绑定到新创建的对象；")]),n._v(" "),o("li",[n._v("由call或者apply调用？绑定到指定对象；")]),n._v(" "),o("li",[n._v("由上下文调用？绑定到上下文对象；")]),n._v(" "),o("li",[n._v("默认：严格模式下绑定到undefined，否则绑定到全局对象；")])]),n._v(" "),o("p",[n._v("另外还需要注意上面提到的几种特殊情况。")])])}),[],!1,null,null,null);a.default=s.exports}}]);