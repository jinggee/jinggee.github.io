(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{573:function(t,e,n){"use strict";n.r(e);var a=n(13),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"什么是vuex"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是vuex"}},[t._v("#")]),t._v(" 什么是Vuex？")]),t._v(" "),n("p",[t._v("官网定义：")]),t._v(" "),n("blockquote",[n("p",[t._v("Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用"),n("strong",[t._v("集中式")]),t._v("存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。")])]),t._v(" "),n("p",[t._v("这段话说明vuex有两个特点：集中管理、状态变化可以预测。 在介绍这两个特点之前，先了解下什么是状态，以及为什么要对状态进行管理。")]),t._v(" "),n("ul",[n("li",[n("p",[n("strong",[t._v("状态是驱动应用的数据源")]),t._v("。")]),t._v(" "),n("p",[t._v("通俗的讲就是组件中绑定的数据。例如：导航控件绑定的菜单数据、控制导航展开或收拢的数据等等。")])]),t._v(" "),n("li",[n("p",[n("strong",[t._v("为什么要状态管理？")])]),t._v(" "),n("p",[t._v("既然状态是组件需要绑定的数据，那为什么不直接写在组件的data方法里呢？当这个状态只在一个组件中使用时，当然直接在data中定义就可以。但是当多个组件都依赖同一个状态或者都会修改同一个状态时，处理起来就比较麻烦。")]),t._v(" "),n("p",[t._v("因为在vue中，组件通过prop注册自定义属性。父组件通过给子组件的自定义属性赋值将数据传给子组件。另外子组件不能直接修改父组件的数据，它可以emit一个事件，将变更后的数据通过事件参数传给父组件，父组件捕获到事件后更新数据。 这样的话对下面这些场景处理起来就很麻烦：")]),t._v(" "),n("ol",[n("li",[t._v("两个兄弟关系（或者毫无关系）的组件都依赖于同一个状态，A组件修改状态后，B组件也要更新；此时A组件无法把修改后的状态传给B。")]),t._v(" "),n("li",[t._v("祖先向后代组件传递数据； 需要通过prop一层层的的传递，非常繁琐。")])])])]),t._v(" "),n("ul",[n("li",[n("p",[n("strong",[t._v("vuex")])]),t._v(" "),n("p",[n("strong",[t._v("集中管理")]),t._v("：vuex把组件的共享状态抽取出来，以一个全局单例模式进行管理，在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为。")]),t._v(" "),n("p",[n("strong",[t._v("状态变化可以预测")]),t._v("：不允许组件直接修改状态，而是在vuex内部，通过mutation来修改状态，这样每次状态的变更都可以追踪；\n"),n("img",{attrs:{src:"https://vuex.vuejs.org/vuex.png",alt:"image"}})])])]),t._v(" "),n("h2",{attrs:{id:"vuex的核心概念"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vuex的核心概念"}},[t._v("#")]),t._v(" Vuex的核心概念")]),t._v(" "),n("p",[t._v("每一个 Vuex 应用的核心就是 store（仓库），store集中管理所有的状态。它和单纯的全局对象比有两点不同：")]),t._v(" "),n("ol",[n("li",[t._v("vuex中的状态是响应式的，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新；")]),t._v(" "),n("li",[t._v("组件不允许直接修改属于store的状态，而应执行 action 来分发 (dispatch) 事件通知 store 去改变，这样使得我们可以方便地跟踪每一个状态的变化；")])]),t._v(" "),n("p",[t._v("创建store对象的时候需要传递构造器选项，具体如下所示。构造器选项有：state, mutations, actions, getters, modules等，下面是这些选项的用法。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('const store = new Vuex.Store({\n  state: {\n    products: [{"id": 1, "title": "iPad 4 Mini", "price": 500.01, "inventory": 2},\n        {"id": 2, "title": "H&M T-Shirt White", "price": 10.99, "inventory": 10},]\n  },\n  getters: {\n    productsCount: state => {\n        return state.products.length;\n    }\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  }\n})\n')])])]),n("ul",[n("li",[n("strong",[t._v("State")])])]),t._v(" "),n("p",[n("strong",[t._v("如何在组件中展示状态？")]),t._v(" 通过在vue根实例中注册store选项，store会注入到所有子组件中，这样子组件能通过this.$store访问到。\n如果组件要显示一个状态，通常会先定义一个计算属性，然后在计算属性返回store中的状态，组件绑定该计算属性。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("<template>\n    <div>\n        {{productsCount}}\n    </div>\n</template>\n\n<script>\nexport default {\n    computed: {\n        productsCount() {\n         return this.$store.state.productsCount;   \n        }\n    }\n}\n<\/script>\n")])])]),n("p",[n("strong",[t._v("mapState辅助函数")]),t._v("\n当一个组件需要获取多个状态时，将这些状态都声明为计算属性会有些重复和冗余，mapState函数可以帮助我们少输入些代码。")]),t._v(" "),n("p",[t._v("例如: store中有两个状态， name, phone")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v(" new Vuex.Store({\n  state: {\n    name: '张绍',\n    phone: '13800138000'\n  },\n  ...\n})\n")])])]),n("p",[t._v("组件中通过mapState获取这两个状态（ ...是ES6中的扩展运算符， 具体用法可参考"),n("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax",target:"_blank",rel:"noopener noreferrer"}},[t._v("《ES6 ... 扩展运算符》"),n("OutboundLink")],1),t._v(")")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("<template>\n    <div>\n        {{name}} / {{phone}}\n    </div>\n</template>\n\n<script>\nimport { mapState } from 'vuex'\n\nexport default {\n    computed: {\n        ...mapState([\n          'phone',\n          'name',\n        ]),\n    }\n}\n")])])]),n("ul",[n("li",[n("strong",[t._v("Getter")]),t._v("\n有时候我们组件需要显示加工处理后的状态数据，例如store中有一个待办任务列表的状态数据，但是组件需要显示已完成的待办任务，如果每个组件都在自己的计算属性进行过滤会重复操作，增加代码量。这个时候可以在store中定义一个getter， 在这个getter中进行计算过滤，然后组件的计算属性中直接返回这个getter。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const store = new Vuex.Store({\n  state: {\n    todos: [\n      { id: 1, text: '...', done: true },\n      { id: 2, text: '...', done: false }\n    ]\n  },\n  getters: {\n    doneTodos: state => {\n      return state.todos.filter(todo => todo.done)\n    }\n  }\n})\n")])])]),n("p",[t._v("组件")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("computed: {\n  doneTodosCount () {\n    return this.$store.getters.doneTodosCount\n  }\n}\n")])])]),n("ul",[n("li",[n("strong",[t._v("Mutation")]),t._v("\n不允许组件直接修改状态，更改状态的唯一方法是提交mutation，然后在mutation中修改；")])]),t._v(" "),n("p",[t._v("在vuex.store的mutations选项中定义一个mutation, mutation回调函数接收一个参数state，通过state取到状态数据。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const store = new Vuex.Store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    increment (state) {\n      // 变更状态\n      state.count++\n    }\n  }\n})\n")])])]),n("p",[t._v("组件中提交mutation更改状态")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("<template>\n    <el-button @click=\"incrementCount\">修改状态</el-button>\n</template>\n\n<script>\nexport default {\n    methods: {\n        incrementCount() {\n            this.$store.commit('increment');\n        }\n    }\n}\n<\/script>\n")])])]),n("ul",[n("li",[n("strong",[t._v("Action")]),t._v("\nmutation中的操作是同步的，如果我们需要在异步执行某些操作后修改状态，则只能使用action。 Action可以包含异步操作，在Action中提交mutation来修改状态。")])]),t._v(" "),n("p",[t._v("定义一个Action")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const store = new Vuex.Store({\n  ...\n  actions: {\n    increment (context) {\n      setTimeout(() => {\n          context.commit('increment')\n        }, 1000)\n    }\n  }\n})\n")])])]),n("p",[t._v("组件中分发Action")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("this.$store.dispatch('increment')\n")])])]),n("ul",[n("li",[n("strong",[t._v("Module")]),t._v("\n对于一个大型的应用，所有的状态都集中在一个对象中，会变得非常臃肿。vuex允许我们将store分割成模块，每个模块拥有自己的state, mutation, action, getter，甚至是嵌套子模块。类似下面代码：")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n")])])]),n("h2",{attrs:{id:"vuex的安装使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vuex的安装使用"}},[t._v("#")]),t._v(" Vuex的安装使用")]),t._v(" "),n("ol",[n("li",[t._v("首先安装vuex")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("npm install vuex --save\n")])])]),n("ol",{attrs:{start:"2"}},[n("li",[t._v("显式地通过Vue.use()，引入vuex")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import Vuex from 'vuex'\n\nVue.use(Vuex)\n")])])]),n("ol",{attrs:{start:"3"}},[n("li",[t._v("实例化Vuex.Store对象")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const store = new Vuex.Store({\n  state: {\n    ...\n  },\n  getters: {\n    ...\n  },\n  mutations: {\n    ...\n  }\n  actions: {\n      ...\n  }\n})\n")])])]),n("ol",{attrs:{start:"4"}},[n("li",[t._v("将store注入到Vue实例中，这样该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("new Vue({\n  el: '#app',\n  router,\n  store,\n  template: '<App/>',\n  components: { App },\n});\n")])])]),n("p",[t._v("注意事项：对于大型的应用，通常会把vuex相关代码分割到模块中，大概的项目结构如下：(官网有个"),n("a",{attrs:{href:"https://github.com/vuejs/vuex/tree/dev/examples/shopping-cart",target:"_blank",rel:"noopener noreferrer"}},[t._v("购物车"),n("OutboundLink")],1),t._v("的例子可以参考)\n"),n("img",{attrs:{src:"https://note.youdao.com/yws/api/personal/file/DE62C649FAFE4DE891DF9AF656701B36?method=download&shareKey=c5335c54c025ea39551f5afa3ef41fb7",alt:"image"}})]),t._v(" "),n("h2",{attrs:{id:"参考资料"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"https://vuex.vuejs.org/zh/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vuex官方文档"),n("OutboundLink")],1)]),t._v(" "),n("li",[n("a",{attrs:{href:"https://cn.vuejs.org/v2/guide/components.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue组件"),n("OutboundLink")],1)]),t._v(" "),n("li",[n("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax",target:"_blank",rel:"noopener noreferrer"}},[t._v("ES6 ... 扩展运算符"),n("OutboundLink")],1)])]),t._v(" "),n("h2",{attrs:{id:"后记"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#后记"}},[t._v("#")]),t._v(" 后记")]),t._v(" "),n("p",[t._v("此文是对官网资料的学习总结，其中夹杂了些自己对vuex的理解，如果有理解有误的地方，欢迎大家指出。")])])}),[],!1,null,null,null);e.default=s.exports}}]);